import { join } from 'node:path';
import { lstat, writeFile, mkdir } from 'node:fs/promises';
import { defineNuxtModule, createResolver, getNuxtVersion, addPlugin, addComponent, extendWebpackConfig } from '@nuxt/kit';
import { VitePWA } from 'vite-plugin-pwa';
import { createHash } from 'node:crypto';
import { createReadStream } from 'node:fs';
import { resolve } from 'pathe';

const version = "0.4.0";

function configurePWAOptions(nuxt3_8, options, nuxt, nitroConfig) {
  if (!options.outDir) {
    const publicDir = nitroConfig.output?.publicDir ?? nuxt.options.nitro?.output?.publicDir;
    options.outDir = publicDir ? resolve(publicDir) : resolve(nuxt.options.buildDir, "../.output/public");
  }
  if (options.devOptions?.enabled)
    options.devOptions.resolveTempFolder = () => resolve(nuxt.options.buildDir, "dev-sw-dist");
  let config;
  if (options.strategies === "injectManifest") {
    options.injectManifest = options.injectManifest ?? {};
    config = options.injectManifest;
  } else {
    options.workbox = options.workbox ?? {};
    if (options.registerType === "autoUpdate" && (options.client?.registerPlugin || options.injectRegister === "script" || options.injectRegister === "inline")) {
      options.workbox.clientsClaim = true;
      options.workbox.skipWaiting = true;
    }
    if (nuxt.options.dev) {
      options.workbox.navigateFallback = options.workbox.navigateFallback ?? nuxt.options.app.baseURL ?? "/";
      if (options.devOptions?.enabled && !options.devOptions.navigateFallbackAllowlist)
        options.devOptions.navigateFallbackAllowlist = [nuxt.options.app.baseURL ? new RegExp(nuxt.options.app.baseURL) : /\//];
    }
    if (!("navigateFallback" in options.workbox))
      options.workbox.navigateFallback = nuxt.options.app.baseURL ?? "/";
    config = options.workbox;
  }
  let buildAssetsDir = nuxt.options.app.buildAssetsDir ?? "_nuxt/";
  if (buildAssetsDir[0] === "/")
    buildAssetsDir = buildAssetsDir.slice(1);
  if (buildAssetsDir[buildAssetsDir.length - 1] !== "/")
    buildAssetsDir += "/";
  if (!("dontCacheBustURLsMatching" in config))
    config.dontCacheBustURLsMatching = new RegExp(buildAssetsDir);
  if (nuxt.options.experimental.payloadExtraction) {
    const enableGlobPatterns = nuxt.options._generate || (!!nitroConfig.prerender?.routes?.length || Object.values(nitroConfig.routeRules ?? {}).some((r) => r.prerender));
    if (enableGlobPatterns) {
      config.globPatterns = config.globPatterns ?? [];
      config.globPatterns.push("**/_payload.json");
    }
  }
  let appManifestFolder;
  if (nuxt3_8 && nuxt.options.experimental.appManifest) {
    config.globPatterns = config.globPatterns ?? [];
    appManifestFolder = `${buildAssetsDir}builds/`;
    config.globPatterns.push(`${appManifestFolder}**/*.json`);
  }
  if (!nuxt.options.dev && !config.manifestTransforms)
    config.manifestTransforms = [createManifestTransform(nuxt.options.app.baseURL ?? "/", options.outDir, appManifestFolder)];
}
function createManifestTransform(base, publicFolder, appManifestFolder) {
  return async (entries) => {
    entries.filter((e) => e.url.endsWith(".html")).forEach((e) => {
      const url = e.url.startsWith("/") ? e.url.slice(1) : e.url;
      if (url === "index.html") {
        e.url = base;
      } else {
        const parts = url.split("/");
        parts[parts.length - 1] = parts[parts.length - 1].replace(/\.html$/, "");
        e.url = parts.length > 1 ? parts.slice(0, parts.length - 1).join("/") : parts[0];
      }
    });
    if (appManifestFolder) {
      const regExp = /(\/)?[0-9a-f]{8}\b-[0-9a-f]{4}\b-[0-9a-f]{4}\b-[0-9a-f]{4}\b-[0-9a-f]{12}\.json$/i;
      entries.filter((e) => e.url.startsWith(appManifestFolder) && regExp.test(e.url)).forEach((e) => {
        e.revision = null;
      });
      const latest = `${appManifestFolder}latest.json`;
      const latestJson = resolve(publicFolder, latest);
      const data = await lstat(latestJson).catch(() => void 0);
      if (data?.isFile()) {
        const revision = await new Promise((resolve2, reject) => {
          const cHash = createHash("MD5");
          const stream = createReadStream(latestJson);
          stream.on("error", (err) => {
            reject(err);
          });
          stream.on("data", (chunk) => cHash.update(chunk));
          stream.on("end", () => {
            resolve2(cHash.digest("hex"));
          });
        });
        const latestEntry = entries.find((e) => e.url === latest);
        if (latestEntry)
          latestEntry.revision = revision;
        else
          entries.push({ url: latest, revision, size: data.size });
      } else {
        entries = entries.filter((e) => e.url !== latest);
      }
    }
    return { manifest: entries, warnings: [] };
  };
}

async function regeneratePWA(_dir, api) {
  if (!api || api.disabled)
    return;
  await api.generateSW();
}
async function writeWebManifest(dir, path, api) {
  const manifest = api.generateBundle({})?.[path];
  if (manifest && "source" in manifest)
    await writeFile(resolve(dir, path), manifest.source, "utf-8");
}

const module = defineNuxtModule({
  meta: {
    name: "pwa",
    configKey: "pwa",
    compatibility: {
      nuxt: "^3.6.5",
      bridge: false
    },
    version
  },
  defaults: (nuxt) => ({
    base: nuxt.options.app.baseURL,
    scope: nuxt.options.app.baseURL,
    injectRegister: false,
    includeManifestIcons: false,
    registerPlugin: true,
    writePlugin: false,
    client: {
      registerPlugin: true,
      installPrompt: false,
      periodicSyncForUpdates: 0
    }
  }),
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    const nuxtVersion = getNuxtVersion(nuxt).split(".").map((v) => Number.parseInt(v));
    const nuxt3_8 = nuxtVersion.length > 1 && (nuxtVersion[0] > 3 || nuxtVersion[0] === 3 && nuxtVersion[1] >= 8);
    let vitePwaClientPlugin;
    const resolveVitePluginPWAAPI = () => {
      return vitePwaClientPlugin?.api;
    };
    const client = options.client ?? { registerPlugin: true, installPrompt: false, periodicSyncForUpdates: 0 };
    const runtimeDir = resolver.resolve("./runtime");
    if (!nuxt.options.ssr)
      nuxt.options.build.transpile.push(runtimeDir);
    if (client.registerPlugin) {
      addPlugin({
        src: resolver.resolve(runtimeDir, "plugins/pwa.client"),
        mode: "client"
      });
    }
    await Promise.all([
      addComponent({
        name: "VitePwaManifest",
        filePath: resolver.resolve(runtimeDir, "components/VitePwaManifest")
      }),
      addComponent({
        name: "NuxtPwaManifest",
        filePath: resolver.resolve(runtimeDir, "components/VitePwaManifest")
      })
    ]);
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({ path: resolver.resolve(runtimeDir, "plugins/types") });
      references.push({ types: "@vite-pwa/nuxt/configuration" });
      references.push({ types: "vite-plugin-pwa/vue" });
      references.push({ types: "vite-plugin-pwa/info" });
    });
    const manifestDir = join(nuxt.options.buildDir, "manifests");
    nuxt.options.nitro.publicAssets = nuxt.options.nitro.publicAssets || [];
    nuxt.options.nitro.publicAssets.push({
      dir: manifestDir,
      maxAge: 0
    });
    nuxt.hook("nitro:init", (nitro) => {
      configurePWAOptions(nuxt3_8, options, nuxt, nitro.options);
    });
    nuxt.hook("vite:extend", ({ config }) => {
      const plugin = config.plugins?.find((p) => p && typeof p === "object" && "name" in p && p.name === "vite-plugin-pwa");
      if (plugin)
        throw new Error("Remove vite-plugin-pwa plugin from Vite Plugins entry in Nuxt config file!");
    });
    nuxt.hook("vite:extendConfig", async (viteInlineConfig, { isClient }) => {
      viteInlineConfig.plugins = viteInlineConfig.plugins || [];
      const plugin = viteInlineConfig.plugins.find((p) => p && typeof p === "object" && "name" in p && p.name === "vite-plugin-pwa");
      if (plugin)
        throw new Error("Remove vite-plugin-pwa plugin from Vite Plugins entry in Nuxt config file!");
      if (options.manifest && isClient) {
        viteInlineConfig.plugins.push({
          name: "vite-pwa-nuxt:webmanifest:build",
          apply: "build",
          async writeBundle(_options, bundle) {
            if (options.disable || !bundle)
              return;
            const api = resolveVitePluginPWAAPI();
            if (api) {
              await mkdir(manifestDir, { recursive: true });
              await writeWebManifest(manifestDir, options.manifestFilename || "manifest.webmanifest", api);
            }
          }
        });
      }
      if (isClient) {
        viteInlineConfig.plugins = viteInlineConfig.plugins || [];
        const configuration = "virtual:nuxt-pwa-configuration";
        const resolvedConfiguration = `\0${configuration}`;
        viteInlineConfig.plugins.push({
          name: "vite-pwa-nuxt:configuration",
          enforce: "pre",
          resolveId(id) {
            if (id === configuration)
              return resolvedConfiguration;
          },
          load(id) {
            if (id === resolvedConfiguration) {
              const display = typeof options.manifest !== "boolean" ? options.manifest?.display ?? "standalone" : "standalone";
              const installPrompt = typeof client.installPrompt === "undefined" || client.installPrompt === false ? void 0 : client.installPrompt === true || client.installPrompt.trim() === "" ? "vite-pwa:hide-install" : client.installPrompt.trim();
              return `export const enabled = ${client.registerPlugin}
export const display = '${display}'
export const installPrompt = ${JSON.stringify(installPrompt)}
export const periodicSyncForUpdates = ${typeof client.periodicSyncForUpdates === "number" ? client.periodicSyncForUpdates : 0}
`;
            }
          }
        });
      }
      const plugins = [...VitePWA(options).filter((p) => p.name !== "vite-plugin-pwa:build")];
      viteInlineConfig.plugins.push(plugins);
      if (isClient)
        vitePwaClientPlugin = plugins.find((p) => p.name === "vite-plugin-pwa");
    });
    extendWebpackConfig(() => {
      throw new Error("Webpack is not supported: @vite-pwa/nuxt module can only be used with Vite!");
    });
    if (nuxt.options.dev) {
      const webManifest = `${nuxt.options.app.baseURL}${options.devOptions?.webManifestUrl ?? options.manifestFilename ?? "manifest.webmanifest"}`;
      const devSw = `${nuxt.options.app.baseURL}dev-sw.js?dev-sw`;
      const workbox = `${nuxt.options.app.baseURL}workbox-`;
      const emptyHandle = (_req, _res, next) => {
        next();
      };
      nuxt.hook("vite:serverCreated", (viteServer, { isServer }) => {
        if (isServer)
          return;
        viteServer.middlewares.stack.push({ route: webManifest, handle: emptyHandle });
        viteServer.middlewares.stack.push({ route: devSw, handle: emptyHandle });
      });
      if (!options.strategies || options.strategies === "generateSW") {
        nuxt.hook("vite:serverCreated", (viteServer, { isServer }) => {
          if (isServer)
            return;
          viteServer.middlewares.stack.push({ route: workbox, handle: emptyHandle });
        });
        if (options.devOptions?.suppressWarnings) {
          const suppressWarnings = `${nuxt.options.app.baseURL}suppress-warnings.js`;
          nuxt.hook("vite:serverCreated", (viteServer, { isServer }) => {
            if (isServer)
              return;
            viteServer.middlewares.stack.push({ route: suppressWarnings, handle: emptyHandle });
          });
        }
      }
    } else {
      if (!options.disable && options.registerWebManifestInRouteRules) {
        nuxt.hook("nitro:config", async (nitroConfig) => {
          nitroConfig.routeRules = nitroConfig.routeRules || {};
          let swName = options.filename || "sw.js";
          if (options.strategies === "injectManifest" && swName.endsWith(".ts"))
            swName = swName.replace(/\.ts$/, ".js");
          nitroConfig.routeRules[`${nuxt.options.app.baseURL}${swName}`] = {
            headers: {
              "Cache-Control": "public, max-age=0, must-revalidate"
            }
          };
          if (options.manifest) {
            nitroConfig.routeRules[`${nuxt.options.app.baseURL}${options.manifestFilename ?? "manifest.webmanifest"}`] = {
              headers: {
                "Content-Type": "application/manifest+json",
                "Cache-Control": "public, max-age=0, must-revalidate"
              }
            };
          }
        });
      }
      if (nuxt3_8) {
        nuxt.hook("nitro:build:public-assets", async () => {
          await regeneratePWA(
            options.outDir,
            resolveVitePluginPWAAPI()
          );
        });
      } else {
        nuxt.hook("nitro:init", (nitro) => {
          nitro.hooks.hook("rollup:before", async () => {
            await regeneratePWA(
              options.outDir,
              resolveVitePluginPWAAPI()
            );
          });
        });
        if (nuxt.options._generate) {
          nuxt.hook("close", async () => {
            await regeneratePWA(
              options.outDir,
              resolveVitePluginPWAAPI()
            );
          });
        }
      }
    }
  }
});

export { module as default };
